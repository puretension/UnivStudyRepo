## 목차

- Semantics of Expressions
- Structured Programming
- Semantics of Statements
- Interpreter of Language S

### **Overview of Semantics**

- 프로그램 의미를 정확하게 정의하고 이해하기 위해서
- 소프트웨어 명세
- 소프트웨어 시스템의 검증, 추론
- 컴파일러, 인터프리터 작성의 기초

### **Types of Semantics**

- Operational Semantics (작동 의미론) - 프로그램 실행과정을 통해 의미 설명
- Denotational Semantics (표시 의미론) - 함수처럼 수식,문장 의미 표시(denotation)
- Axiomatic Semantics (공리 의미론) - 논리적선언(logical assertion)으로 프로그램 상태 표명(assertion)

## 1. 수식의 의미(**Semantics of Expressions)**

**어떤 상태(State)에서 수식(Expr)의 값(Value)**은 **함수 V**로 정의 가능 ⇒ `V: (State,Expr) → Value`

- `s = {x ↦1, y ↦ 2}`
- `V(s, x+y) = 3`

**간단한 수식(Simple Expression)**

- E → true | false | n | str | id
- V(s, true) = T
- V(s, false) = F
- V(s, n) = n
- V(s, str) = str
- V(s, id) = s(id)

**산술 연산(Arithmetic Expression)**

- E →E + E | E - E | E * E | E / E
- 덧셈연산 ⇒ V(s, E1 + E2) = V(s, E1) + V(s, E2),나머지 연산도 떠올려보기

**비교 연산(Comparison Expression)**

- E → E > E | E < E | E == E | E != E
- V(s, E1 == E2) = T if V(s, E1) == V(s, E2)
- V(s, E1 == E2) = F if V(s, E1) != V(s, E2)

**연산자 우선순위(Operator Precedence)**

- 수식의 값은 연산자 우선순위와 결합성(operator precedence and associativity)에 영향받음
- 연산자 우선순위: 연산자를 실행하는 순서로 우선순위가 더 높은 연산자가 먼저 실행됨
- a+b*c를 AST로 떠올려보기, 쓰이는 항들은?
    
    ```
    E -> E + T | T
    T -> T * F | F
    F -> n | id
    ```
    

**C Operator Precedence**

| 연산자 그룹 | 연산자 | 기억 요령 |
| --- | --- | --- |
| 산술 연산자 | */% | 계산하여 |
| 산술 연산자 | +- |  |
| 비교 연산자 | < <= > >= == != | 비교한 후 |
| 논리 연산자 | && || | 판단하여 |
| 조건 연산자 | ?: |  |
| 대입 연산자 | = += -= *= /= %= &= ^= |= <<= >>= | 저장한다. |

**연산자 결합성(Operator Associativity)**

- `(a - b) - c` ≠ `a - (b - c)`  ⇒ 각각 AST 떠올려보기
- 좌결합(Left Associative)
    - 왼쪽부터 오른쪽으로 결합하며, 대부분의 **이항(binary) 연산자**들은 **left-to-right** associativity rule
    - `left recursive rule` 로 -(빼기) 연산자의 좌결합성을 표현하면?
        
        ![스크린샷 2023-10-15 오후 5.46.47.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/e86987c6-0a84-4703-9681-51c46278c67e/16929812-c335-464f-a0cf-dd3cf77b9c34/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7_2023-10-15_%EC%98%A4%ED%9B%84_5.46.47.png)
        
- 우결합(Right Associative)
    - 대부분의 **단항 연산자와 대입 연산자**는 **right-to-left** associativity rule
    - `right recursive rule` 로 ! 단항 연산자의 우결합성을 표현하면?
        
        ![스크린샷 2023-10-15 오후 5.52.53.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/e86987c6-0a84-4703-9681-51c46278c67e/d8244773-4698-4065-acc4-47abded36f07/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7_2023-10-15_%EC%98%A4%ED%9B%84_5.52.53.png)
        

## 2. 구조적 프로그래밍(**Structured Programming**)

### GoTo 문

![스크린샷 2023-10-15 오후 5.55.33.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/e86987c6-0a84-4703-9681-51c46278c67e/6b86307d-e49f-4238-aa97-daaaa58274b5/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7_2023-10-15_%EC%98%A4%ED%9B%84_5.55.33.png)

- Fortran과 같은 초기 프로그래밍 언어에서는 코드 구조를 개선하기 위해 새로운 제어 구조(control section)를 도입하려 노력함
- Dijkstra, Goto Statement Considered Harmful → 가독성과 유지보수성을 떨어뜨리기때문
- Knuth, Structured Prog. with go to Statements → You can use goto, but do so in structured way(**구조적 프로그래밍**의 경우에 따라 goto문 사용하는게 좋기도 하다)

### 구조적 프로그래밍(**Structured Programming)**

- goto문 대신에, 시작과 끝지점이 일정한 구조적 구문을 사용하자!
- 시작,끝 일정하기에, 프로그램의 각각의 구조와 그 사이의 관계를 이해하면 프로그램의 전체를 보다 쉽게 이해할 수 있다는 장점
- Böhm & Jacopini(1966)는 어떤 computational function든 `순차(sequence) 선택(selection) 반복(repetition)` 3개중 하나
- 순차(concatenation): 구문 순서에 따라 순서대로 수행
- 선택(selection): 프로그램 상태기반, 여러 구문중 하나 수행, `if, switch`
- 반복(repetition): 반복문, `while, repeat, for`

![스크린샷 2023-10-15 오후 6.06.31.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/e86987c6-0a84-4703-9681-51c46278c67e/451e04b7-ab8b-4665-8012-b5d0f4830186/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7_2023-10-15_%EC%98%A4%ED%9B%84_6.06.31.png)

언어 S의 문장 구문 구조도 Structured Programming

- Integer `n ∈ Int`
- Variable `id ∈ Var`
- Expression `E ∈ Exp`
- Stmt, Type,Expr

```
Stmt S → id = E //대입문
| S; S //복합문이며 ;으로 문장 분리
| let T id [= E] in S end // let문으로, S라는 표현식에서, T 타입의 id변수에 E를 할당
| let T x = E in S end // let문으로, S라는 표현식에서, T 타입의 x변수에 E를 할당(복습)
| if E then S [else S] //let문
| while ( E ) S //반복문
| read id //입력문
| print E //출력문
Type T -> int | bool | string
Expr E → n|id|true|false|E+E|E–E|E*E|E/E|(E)|E==E|E<E|E>E|!E
물론 함수도 있음
fun T f(T x) S 
```

언어 S에서는 let문이 블록역할함(Block Structured Programming)

```
read x;
y = 1;
while (x != 1) {
y = y*x;
x = x-1;
}
```

x값읽고, y에 1대입후, `x가 1아닌지 검사후, 거짓이면 종료하고, 참이면 y=xy, x-=1후` while문 반복

### 설탕 구문(**Syntactic Sugar)**

- 언어 S는 필수적인 몇 문장만 제공하는 반면 일반 프로그래밍언어는 부가적인 문장도 제공함 → 설탕 구문이라 부른다
- do S while (E), for (e1; e2; e3) S, switch(E)
    
    ![스크린샷 2023-10-15 오후 6.23.03.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/e86987c6-0a84-4703-9681-51c46278c67e/9d5bc7fc-2a6d-4e0b-bdd3-be1d60da50ac/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7_2023-10-15_%EC%98%A4%ED%9B%84_6.23.03.png)
    

## 3. 문장의 의미(**Semantics of Statements**)

프로그램이 실행중일때 변수들이 현재 갖고있는 값은? State(상태)

상태는 식별자 집합 Identifier에서 값 집합 Value로 가는 하나의 함수로 정의가능하며,

이러한 실행과정을 **state transitions**

`(s, S) → s’` : 문장 실행전 상태 s를 S문장 실행하여 s’로 변경시킨다(S changes the preceding state s to the subsequent state s')

![스크린샷 2023-10-15 오후 6.26.17.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/e86987c6-0a84-4703-9681-51c46278c67e/0d5e8620-8ea2-42c5-80ae-e8b9907d559b/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7_2023-10-15_%EC%98%A4%ED%9B%84_6.26.17.png)

상태전이관계는 **상태변환함수(State transform function)** `Eval`로 정의가능

State는 모든 가능한 상태들의 집합, Statement는 모든 문장들의 집합

`Eval: (State, Statement) → State`

이 상태변환함수는 문장 S(Statement)로 실행하기전 상태를 받아 문장 S를 실행한후의 상태를 리턴함

`Eval(s, S) = s’ for each statement S`

### 대입문(Assignment Statement):  `id = E`

- `Eval(s, id = E) = s[id ↦ V(s, E)]`

![스크린샷 2023-10-15 오후 6.47.21.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/e86987c6-0a84-4703-9681-51c46278c67e/7ca71834-1e6d-4fb6-84b8-8794e0b71298/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7_2023-10-15_%EC%98%A4%ED%9B%84_6.47.21.png)

### 복합문(Compound Statement):  `S; S`

- `Eval(s, S1;S2) = Eval(Eval(s, S1), S2)`
    
    ![스크린샷 2023-10-15 오후 6.47.51.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/e86987c6-0a84-4703-9681-51c46278c67e/bb7f931d-5a03-4fa0-bf17-dce25cf64df5/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7_2023-10-15_%EC%98%A4%ED%9B%84_6.47.51.png)
    

### let문: `let T id [=E] in S end`

- 변수선언을 만나면 변수가 유효해지므로,  이 변수를 위한 엔트리를 E값으로 초기화하여 실행 전 상태 s에 추가해야함
- 이 상태에서 문장 S를 실행하면 상태가 변하게 되고, let문 실행 후에는 선언된 변수가 더 이상 유효하지 않으므로 실행후에 상태에서 해당 엔트리를 제거해야함. 아래는 이러한 상태전이관계를 표현함

```
(s[id ↦ V(s,E)], S) → s’[id ↦ *] 
(s, let T id =E in S end) → s’
```

이를 상태변환함수 Eval로 표현하면?

```
Eval(s, let T id=E in S end) = s’
if s’[id ↦ *] = Eval(s[id ↦ V(s,E)], S)
```

변수의 해당 엔트리 제거를 `\`로 표현, 엔트리 추가 제거를 `push, pop` 으로 표현

### let문 예제

![스크린샷 2023-10-15 오후 6.44.11.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/e86987c6-0a84-4703-9681-51c46278c67e/919fa5c9-3ffe-4dc5-bb09-9ea2fdfb54ed/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7_2023-10-15_%EC%98%A4%ED%9B%84_6.44.11.png)

### 대입문, 복합문 예제

![스크린샷 2023-10-15 오후 6.43.30.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/e86987c6-0a84-4703-9681-51c46278c67e/f9f84515-5eaf-412f-923f-2c4ada0474c1/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7_2023-10-15_%EC%98%A4%ED%9B%84_6.43.30.png)

위의 let 문에서 

복합문y= y + 1; X= x +y을 실행하면 실행전상태 S에서 다음과 같이 순차적으로 변경됨 

![스크린샷 2023-10-15 오후 6.52.15.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/e86987c6-0a84-4703-9681-51c46278c67e/33f0fb81-a9d1-4e65-b049-e415fe368f4a/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7_2023-10-15_%EC%98%A4%ED%9B%84_6.52.15.png)

아래부터 조건문 시작 ㄱㄱ
