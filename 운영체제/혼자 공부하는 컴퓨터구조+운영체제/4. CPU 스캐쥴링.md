# CPU 스캐쥴링

## CPU 스캐쥴링

- 운영체제가 프로세스들에게 공정하고 합리적으로 CPU 자원을 배분하는 것
- 프로세스마다 우선순위는 다름(급한 프로세스부터 우선 실행되어야함)

### 프로세스

- 프로세스는 `실행상태`와 `대기상태`를 반복하며 실행
- 프로세스마다 입출력장치와 CPU를 이용하는 시간의 차이가 존재함

### 입출력 집중 프로세스(I/O bound process)

- 입출력 작업이 많은 프로세스
- 입출력상태(대기 상태)에 시간을 많이 사용함
- I/O burst(입출력장치를 기다리는 작업)가 많은 프로세스

### CPU 집중 프로세스(CPU bound process)

- CPU 사용에 시간을 많이 사용함
- CPU burst(CPU 이용 작업)가 많은 프로세스

### 프로세스의 우선순위

- 입출력 집중 프로세스가 CPU 집중 프로세스보다 우선순위가 높음 Why?
    - → 입출력 집중 프로세스를 빨리 실행해 입출력장치를 먼저 작동시키고, 그 다음 CPU 집중 프로세스에 CPU 집중 할당하는게 효율적이기때문
- 입출력 집중 프로세스는 입출력 작업이 완료되기전까지 어차피 대기상태에 있기에, 그 시간동안 CPU 집중 처리 프로세스를 끝내는게 더 효율적임

### 프로세스 관리의 비효율성 발생문제

- OS가 프로세스마다 우선순위를 확인하는 것(모든 PCB 뒤적뒤적..)은 비효율적
    - → 스캐쥴링 큐가 필요한 이유
        
<img width="652" alt="스크린샷 2024-03-06 오후 5 22 10" src="https://github.com/puretension/UnivStudyRepo/assets/106448279/21ba7768-5a79-4fd8-8ccf-cd2299491eb5">        

## 스케쥴링 큐

- 프로세스들은 사용할 자원을 요청하고, 해당 자원의 대기줄에서 허가응답을 기다림
- 일반적인 큐(FIFO)와는 다름(선입선출 X)
- 준비 큐(ready queue)와 대기 큐(waiting queue)가 있음
    - 준비큐 → CPU 이용을 위해 준비 상태에 있는 프로세스가 서는 줄
    - 대기큐 → 입출력장치 이용을 위해 대기 상태에 있는 프로세스가 서는 줄

<img width="602" alt="스크린샷 2024-03-06 오후 5 22 18" src="https://github.com/puretension/UnivStudyRepo/assets/106448279/4ce78ad1-3723-4de5-9053-83e31ce1205e">

### 준비 큐

- 준비상태에 있는 프로세스의 PCB는 준비 큐에 삽입되어 CPU 사용을 기다림
- 운영체제는 PCB 삽입 순서(order)대로 프로세스를 인출은 하지만, 우선순위가 높은 프로세스가 먼저실행됨(순서가 뒤에더라도, 우선순위가 높으면 먼저 실행)

### 대기 큐

- 입출력작업이 완료되어 완료인터럽트 발생시 운영체제는 해당 PCB를 대기큐에서 제거, 준비큐로 이동함
- 같은 입출력장치를 요구한 프로세스들은 같은 대기큐에 존재

<img width="679" alt="스크린샷 2024-03-06 오후 5 22 25" src="https://github.com/puretension/UnivStudyRepo/assets/106448279/cffab5e5-5826-4f0e-a579-595e12c275f0">

### process state diagram

<img width="591" alt="스크린샷 2024-03-06 오후 5 23 48" src="https://github.com/puretension/UnivStudyRepo/assets/106448279/afbbd333-559c-4deb-acca-d276dd26a873">

## 선점형과 비선전형 스케쥴링

한 프로세스가 자신의 차례가 되어서 CPU를 실행중인데, 급하게 실행해야하는  다른 프로세스가 나타난다면?

2가지 방법이 있음

- 현재 CPU를 사용중인 프로세스로부터 CPU가 자원을 빼앗아 다른(급한) 프로세스에 할당 → 선점형 스케쥴링
- 현재 CPU를 사용중인 프로세스작업이 끝날때까지 기다리기 → 비선점형 스케쥴링

### 선점형 스케쥴링(preemptive scheduling)

- OS가 현재 CPU를 사용중인 프로세스로부터 CPU가 자원을 빼앗아 다른(급한) 프로세스에 할당
- 하나의 프로세스가 자원을 독점할 수 없다는 특징
- 타이머인터럽트가 있었던 이유(특정 시간만큼 자원 사용후, 시간이 지나면 타이머 인터럽트 발생해 CPU가 자원을 빼앗아 다른 프로세스에 할당됨
- 장점: 급한 프로세스 선처리 가능, 자원 독점 방지
- 단점:  overhead while context switching

### 비선점형 스케쥴링(non-preemptive scheduling)

- 하나의 프로세스가 사용종료(terminated)되거나, 스스로 대기상태(waiting)로 변경되기전까지 다른프로세스가 해당자원 사용불가한 스케쥴링
- 하나의 프로세스가 자원을 독점할 수 있다는 특징
- 장점: context switching이 적기에 `overhead` 발생 X
- 단점: 한 프로세스의 자원사용이 끝날때까지 무조건 기다려야함

### 용어 정리

- 타이머 인터럽트(Timer Inturrupt)?

→ 프로세스의 CPU 자원을 할당받는 시간이 끝났을때

- 오버헤드(overhead)?

→ 어떤 처리를 하기위해 들어가는 간접적인 처리 시간, 메모리 등이 추가적으로 사용되는 현상

## CPU 스캐쥴링 알고리즘

작동방식, 장단점에 집중

### 선입 선처리 스케쥴링(FCFS; First Come First Served)

- 단순히 준비 큐에 삽입된 순서대로 처리하는 비선점 스케쥴링
- 단점 → 호위효과(convoy effect) 발생:  단지 늦게 입력되었다는 이유만으로 프로세스 대기시간이 증가함

### 최단 작업 우선 스케쥴링(SJFS; Shortest Job First Scheduling)

- 준비 큐에 삽입된 프로세스중 `CPU 이용시간이 가장 짧은 프로세스부터 실행`하는 **비선점형** 스케쥴링
- 장점 → 호위효과(convoy effect)  방지 가능

<img width="703" alt="스크린샷 2024-03-06 오후 5 23 54" src="https://github.com/puretension/UnivStudyRepo/assets/106448279/b82e2faf-9108-4f4c-a90e-783b115bc05e">

### 라운드 로빈 스케쥴링(RRS; Round-Robin Scheduling)

- 선입 선처리 스케쥴링(FCFS) + 타임 슬라이스(time slice)
- 타임 슬라이스: 각 프로세스가 CPU 사용할 수 있는 정해진 시간
- 큐에 삽입된 `순서대로` 정해진 `타임 슬라이스` 만큼의 시간동안 돌아가며 CPU 이용하는 **선점형** 스케쥴링
    - 큐에 삽입된 프로세스들은 순서대로 CPU 이용하되, 정해진 시간만큼만 이용
    - 타임 슬라이스안에 완료되지 못하면 context switching 발생 (자원 사용이 중지, 큐의 맨뒤에 재삽입)
- 타임 슬라이스 크기가 매우 중요함
    - 지나치게 긴 경우: 선점형 스케줄링과 차이가 없어 호위 효과가 발생할 수 있음
    - 지나치게 짧은 경우: 문맥 교환 발생 비용이 커 프로세스 전환에 오버헤드가 크게 발생할 수 있음

### 최소 잔여 시간 우선 스케쥴링(SRTS; Shortest Remaining Time Scheduling)

- 최단 작업 우선 스케쥴링(SJFS) + 라운드 로빈 스케쥴링(RRS)
- 프로세스들은 정해진 타임 슬라이스만큼 CPU를 사용하되, 다음 프로세스는 남아있는 작업 시간이 가장 작은 프로세스 선택
- SJFS → 작업시간이 짧은 프로세스부터 처리
- RRS → 정해진 타임슬라이스만큼 처리

### 우선순위 스케쥴링

- 프로세스에 우선순위를 부여하고, 가장 높은 우선수위인 프로세스부터 실행
- 우선순위가 같다면? 선입 선처리로 스케쥴링
- SJFS(Shorest Job First Scheduling), SRTS(Shortest Remaining Time Scheduling)가 포함됨
- 단점? → 기아(starvation)현상 발생
    - → 우선순위가 낮은 프로세스는 준비 큐에 삽입된 순서에 상관없이 우선순위가 높은 프로세스들에 의해 실행이 계속 연기되는 현상
    - 이를 방지하기위해 에이징(aging) 기법 탄생함
    - aging이란 대기중인 프로세스의 우선순위를 마치 나이를 먹듯 점차 증가시키는 방법
        
        <img width="648" alt="스크린샷 2024-03-06 오후 5 24 01" src="https://github.com/puretension/UnivStudyRepo/assets/106448279/854eb039-7e20-4770-9c89-986e356b685a">

### 다단계 큐 스케쥴링(multi-level queue scheduling)

- 우선순위별로 준비큐를 여러개 사용하는 스케쥴링 방식
    - 우선순위가 가장 높은 큐에있는 프로세스를 먼저 처리
    - 우선순위가 가장 높은 큐가 비어있으면 그다음 우선순위 큐에있는 프로세스 처리
- 장점? → 프로세스 유형별 우선순위를 큐로 구분해 실행하기 편하고 큐마다 다른 타임 슬라이스 설정가능
- 단점? → 프로세스들이 큐 사이를 이동할 수 없어 기아 현상이 발생. 이를 해결하기위해 아래의 마지막..등장

### 다단계 피드백 큐 스케쥴링(multi-level feedback queue scheduling)

- 다단계 큐 스케줄링 + 프로세스들이 큐 사이를 이동가능
- 새로 준비 상태가 된 프로세스는 우선순위가 가장 높은 큐에 삽입되고 일정 시간 실행
- 실행 시간 동안 종료되지 못한 경우 프로세스의 우선순위는 점점 낮아짐
- CPU를 오래 사용하는 프로세스(CPU 집중 프로세스)는 우선순위가 점차 낮아지고, 입출력 집중 프로세스들은 우선순위는 상대적으로 높아짐
- 가장 일반적인 스케쥴링 방식임
- 장점? → 프로세스들이 큐 사이를 이동할 수 있어 `에이징(aging)` 기법을 통해 기아 현상을 예방
- 단점? → 구현 복잡
