# 2. 프로세스
[혼자 공부하는 컴퓨터구조+운영체제(저자 강민철)](https://www.yes24.com/Product/Goods/111378840)과 [유튜브 강의](https://www.youtube.com/watch?v=isj4sZhoxjk&list=PLYH7OjNUOWLUz15j4Q9M6INxK5J3-59GC&index=2)를 보고 정리한 글입니다. 
내용 하단부에는 관련 면접문항으로 정리합니다.

# 2.1 프로세스 개요

## 프로세스 유형
### Foreground Process

- 사용자가 볼 수 있는 공간에서 실행되는 프로세스

### Background Process

- 사용자와 직접 상호작용 가능한 프로세스

 사용자와 상호작용하는 백그라운드 프로세스와 그렇지 않은 프로세스가 있다?

### 데몬(demon)
- 유닉스 체계 운영체제에서 사용자와 상호작용하지 않는 프로세스를 부르는 명칭
### 서비스(service)
- 윈도우 체계 운영체제에서 사용자와 상호작용하지 않는 프로세스를 부르는 명칭 

## 프로세스 제어 블록(PCB)
- 모든 프로세스는 실행을 위해 CPU가 필요함 But **CPU 자원은 한정적**
- 프로세스들은 돌아가며 한정된 시간만큰만 CPU 이용함
    - 자신의 차례에 정해진 시간만큼 CPU 이용
    - **타이머 인터럽트**가 발생하면 차례 양보
- 빠르게 번갈아 수행되는 프로세스들을 관리해야함
- 이를 위해 사용하는 자료구조가 `프로세스 제어 블록(PCB)`⭐️
    - 프로세스 관련 정보를 저장하는 자료 구조
    - 마치 **상품에 달린 태그**와 같은 정보
    - 프로세스 생성시 `커널 영역`에 생성, 종료시 폐기

### PCB 특징

- 커널 영역에서 생성된다.
- 프로세스 실행 시에 PCB가 생성되고, 종료 시에 PCB는 삭제된다.
        
![스크린샷 2024-03-05 오후 3 58 50](https://github.com/puretension/UnivStudyRepo/assets/106448279/04230f83-6888-40b8-a98e-cdaa0a4c235e)


### → 운영체제는 커널 영역에 저장된 PCB를 보고 프로세스를 관리함

### PCB에 담기는 대표적인 정보

- PID(Process ID)
    - 특정 프로세스를 식별하기위해 부여하는 고유한 번호
- 레지스터 값
    - 레지스터 값이 왜 프로세스 제어 블록에 저장될까?
    - 프로세스는 자신의 실행차례가 오면 이전까지 사용한 레지스터 중간 값을 모두 복원 → 실행 재게
    - Program Counter, Stack Pointer
    - 각 프로세스는 PC를 통해 다음 프로세스의 주소값을 알고 있으므로 ...
- 프로세스 상태
    - 입출력 장치를 사용하기 위해 기다리는 상태
    - CPU를 사용하기 위해 기다리는 상태
    - CPU를 이용중인 상태
- 메모리 정보
    - 프로세스가 어느 주소에 저장되어 있는지에 대한 정보
    - 페이지 테이블 정보(지금으로서는 메모리 주소를 알고 있는 정보가 담기는가 정도만 이해하자)
- 사용한 파일과 입출력장치 정보
    - 할당된 입출력장치, 사용중인(열린) 파일 정보

### Context Switch⭐️

- 한 프로세스에서 다른 프로세스로 `실행 순서` 가 넘어간다면?
- 기존에 실행되던 프로세스 A는 지금까지의 `중간 정보`를 백업
    - 프로그램 카운터, 각종 레지스터 값, 메모리 정보, 열었던 파일, 사용한 입출력 장치 등
    - 이러한 중간정보들을 뭐라 부르나? → `Context(문맥)`
    - 다음 차례가 왔을때 실행을 재개하기 위한 정보
    - **실행 문맥을 백업해두면 언제든 해당 프로세스의 실행을 재개할 수 있다!**
    

정리하면?

- 기존의 실행 중인 프로세스 문맥을 백업하고
- 새로운 프로세스 실행을 위해 문맥을 복구하는 작업
- Context Switch
    - 여러 프로세스가 끊임없이 빠르게 번갈아 가며 실행되는 원리

![스크린샷 2024-03-05 오후 3 58 56](https://github.com/puretension/UnivStudyRepo/assets/106448279/6ff6e063-2c69-4421-a7ab-ce727e76ac02)

프로세스 A의 실행이 끝나면 프로세스 A의 문맥을 PCB에 저장하고,

PCB로부터 프로세스 B의 문맥을 가져와서 프로세스 B를 실행

프로세스 B의 실행이 끝나면 프로세스 B의 문맥을 PCB에 저장하고,

PCB로부터 프로세스 A의 문맥을 가져와서 프로세스 A를 실행

![스크린샷 2024-03-05 오후 3 59 01](https://github.com/puretension/UnivStudyRepo/assets/106448279/72b8b3a4-8238-4c53-aeb4-e9119bf583c1)

### 프로세스의 메모리 영역

- 크게 코드 영역, 데이터 영역, 힙 영역, 스택 영역
- 코드 영역(= 텍스트 영역)
    - 실행할 수 있는 코드, 기계어로 이루어진 명령어 저장
    - 데이터가 아닌 CPU가 실행할 명령어가 담기므로 read-only 영역
- 데이터 영역
    - 잠깐 썻다가 없앨 데이터가 아니라 프로그램이 실행되는 동안 유지할 데이터를 저장함
    - e.g. 전역 변수
- 힙 영역
    - 프로그래머가 직접 할당할 수 있는 저장공간
- 스택 영역
    - 데이터가 일시적으로 저장되는 공간
    - 임시사용 값들이 저장되는 공간
    - e.g. 지역 변수
- 힙 영역과 스택 영역의 크기는 가변적임
    - 일반적으로 힙 영역은 낮은 주소 → 높은 주소로 할당
    - 일반적으로 스택 영역은 높은 주소 → 낮은 주소로 할당
 


# 2.2 프로세스 상태와 계층구조

diagram을 그린후 transition 설명이 가능해야 이해했다고 볼 수 있음

![스크린샷 2024-03-05 오후 4 00 46](https://github.com/puretension/UnivStudyRepo/assets/106448279/f74387fe-5be6-4f10-844a-6c751c459109)

- 생성 상태
    - 이제 막 메모리에 적재되어 PCB를 할당받은 상태
    - 준비가 완료되었다면 준비 상태로
- 준비 상태
    - 당장이라도 CPU를 할당받아 실행할 수 있지만
    - 자신의 차례가 아니기에 기다리는 상태
    - 자신의 차례가 된다면 실행상태로!(준비상태에서 실행사태가 되는걸 부른는말? → `dispatch`)
- 실행 상태
    - CPU를 할당받아 실행중인 상태
    - 할당된 시간 모두 사용시(타이머 인터럽트 발생시) 준비 상태로
    - 실행 도중 입출력장치를 사용하면(그럴일많음ㅇㅇ) 입출력작업이 끝날때까지 대기 상태로
    - 프로세스 종료시 종료상태로
- 대기 상태
    - 프로세스가 실행 도중 입출력장치를 사용하는 경우
    - 입출력작업은 CPU에 비해 느리기에 이 경우 대기 상태로 접어듬
    - 입출력 작업이 끝나면 (입출력 완료 인터럽트 받으면) 준비 상태로
    - 근데 왜 실행에서 전환?(입출력 장치의 작업속도는 CPU 작업속도보다 느리기때문에 전환되는거)
- 종료 상태
    - 프로세스가 종료된 상태
    - PCB, 프로세스의 메모리 영역 정리
    

### 프로세스 상태변화를 다이어그램을 그린후 설명해보시오.

`new-ready-running-waiting-terminated`에 빗대어 소개하면

`new(생성)`상태는 이제 막 메모리에 적재되어 PCB를 할당받은 상태로 여기서 준비가 완료되면 

`ready(준비)`상태가 된다. ready상태는 CPU를 할당받아 실행가능하나 자신의 차례가 되어야 실행가능하다.

자신의 차례가 되면 실행상태가 되는 dispatch가 발생한다.

`running(실행)`상태는 CPU를 할당받아 실행중인 상태로

 Timer Interrupt발생시 ready로 돌아가고,

I/O(입출력장치) 사용시 `waiting(대기)` 상태가 되며 

프로세스가 종료되면 `terminated(종료)`가 되고 PCB, 프로세스의 메모리영역을 정리한다.

ready(대기)상태에서 입출력작업이 완료되면 다시 준비상태가 된다.

### 프로세스 계층 구조

- 프로세스 실행 도중(시스템 호출을 통해) 다른 프로세스 생성 가능
- 새 프로세스를 생성한 프로세스: `부모 프로세스`
- 부모 프로세스에 의해 생성된 프로세스: `자식 프로세스`

부모 프로세스와 자식 프로세스는 별개의 프로세스이므로 각기 다른 PID를 가진다

일부 운영체제에서는 자식 프로세스 PCB에 부모 프로세스 PID(**PPID**)를 명시하기도 한다

![스크린샷 2024-03-05 오후 4 01 17](https://github.com/puretension/UnivStudyRepo/assets/106448279/4b71d86e-bdf6-468f-98d6-40ed827a390c)

### 프로세스 생성 기법 → Fork-exec

- 부모 프로세스는 `fork 시스템 호출`을 통해 자신의 복사본을 자식 프로세스로 생성(복제)
- 자식 프로세스는 `exec 시스템 호출`을 통해 자신의 메모리 공간을 다른 프로그램으로 교체(옷 갈아입기)

### fork 시스템 호출

- 복사본(=자식 프로세스) 생성
- 부모 프로세스의 자원 상속

### exec 시스템 호출

- 메모리 공간을 새로운 프로그램으로 덮어쓰기
- 코드/데이터 영역은 실행할 프로그램 내용으로 바뀌고 나머지 영역은 초기화

![스크린샷 2024-03-05 오후 4 01 23](https://github.com/puretension/UnivStudyRepo/assets/106448279/e48cc89d-9968-4e3b-8f3b-5a3b90c39040)


### 3. 프로세스가 무엇인가요?
- 프로그램과 프로세스, 스레드의 차이에 대해 설명해 주세요.
- PCB가 무엇인가요?
- 그렇다면, 스레드는 PCB를 갖고 있을까요?
- 리눅스에서, 프로세스와 스레드는 각각 어떻게 생성될까요?
- 자식 프로세스가 상태를 알리지 않고 죽거나, 부모 프로세스가 먼저 죽게 되면 어떻게 처리하나요?
- 리눅스에서, 데몬프로세스에 대해 설명해 주세요.
- 리눅스는 프로세스가 일종의 트리를 형성하고 있습니다. 이 트리의 루트 노드에 위치하는 프로세스에 대해 설명해 주세요.
### 4. 프로세스 주소공간에 대해 설명해 주세요.
- 초기화 하지 않은 변수들은 어디에 저장될까요?
- 일반적인 주소공간 그림처럼, Stack과 Heap의 크기는 매우 크다고 할 수 있을까요? 그렇지 않다면, 그 크기는 언제 결정될까요?
- Stack과 Heap 공간에 대해, 접근 속도가 더 빠른 공간은 어디일까요?
- 다음과 같이 공간을 분할하는 이유가 있을까요?
- 스레드의 주소공간은 어떻게 구성되어 있을까요?
- "스택"영역과 "힙"영역은 정말 자료구조의 스택/힙과 연관이 있는 걸까요? 만약 그렇다면, 각 주소공간의 동작과정과 연계해서 설명해 주세요.
- IPC의 Shared Memory 기법은 프로세스 주소공간의 어디에 들어가나요? 그런 이유가 있을까요?
- 스택과 힙영역의 크기는 언제 결정되나요? 프로그램 개발자가 아닌, 사용자가 이 공간의 크기를 수정할 수 있나요?


### 3. 프로세스란?

프로세스는 실행 중인 프로그램의 인스턴스로, 운영 체제로부터 자원을 할당받아 작업을 수행합니다. 메모리, CPU 시간, I/O 등 필요한 자원과 실행 상태 정보를 포함합니다.

### 프로그램, 프로세스, 스레드 차이

- **프로그램**: 저장 장치에 저장되어 있으며 실행되지 않는 정적인 코드와 데이터의 집합입니다.
- **프로세스**: 프로그램이 실행되어 시스템 자원을 할당받은 상태입니다. 독립적인 메모리 공간을 가지며, 최소 하나의 스레드를 포함합니다.
- **스레드**: 프로세스 내에서 실행되는 실행 단위로, 프로세스의 자원을 공유하며 작업을 수행합니다. 스레드는 프로세스 내에서 코드, 데이터, 힙 영역을 공유하면서 각자의 스택을 가지고 실행됩니다.

### PCB(Process Control Block)

PCB는 특정 프로세스에 대한 중요 정보를 저장하는 운영 체제의 자료구조입니다. 프로세스 상태, 프로그램 카운터, 레지스터 값, 메모리 관리 정보, 계정 정보 등이 포함됩니다.

### 스레드와 PCB

스레드는 독립적인 PCB를 갖지 않습니다. 대신, 같은 프로세스 내의 스레드들은 해당 프로세스의 PCB를 공유하며, 각 스레드는 자신만의 스택과 프로그램 카운터를 가지고 실행됩니다.

### 리눅스에서의 프로세스와 스레드 생성

- **프로세스 생성**: `fork()` 시스템 콜을 사용하여 현재 프로세스의 복사본인 자식 프로세스를 생성합니다.
- **스레드 생성**: `pthread_create()` 함수를 사용하여 같은 프로세스 내에서 실행되는 새로운 스레드를 생성합니다.

### 고아 프로세스와 좀비 프로세스 처리

- **고아 프로세스**: 부모 프로세스가 먼저 종료되면, 고아 프로세스는 init 프로세스의 자식이 되어 init 프로세스가 종료를 관리합니다.
- **좀비 프로세스**: 자식 프로세스가 종료되었으나 부모 프로세스가 종료 상태를 회수하지 않아 메모리에 남아 있는 상태입니다. 부모 프로세스가 `wait()`를 호출하여 자식 프로세스의 종료 상태를 회수하면 좀비 프로세스는 제거됩니다.

### 데몬 프로세스

데몬 프로세스는 사용자의 직접적인 개입 없이 백그라운드에서 실행되는 프로세스입니다. 시스템 로깅, 스케줄링 작업, 네트워크 요청 처리 등을 담당합니다.

### 리눅스 프로세스 트리와 루트 노드

리눅스 시스템에서 모든 프로세스는 트리 구조를 형성하며, 이 트리의 루트 노드는 PID가 1인 `init` 프로세스 또는 `systemd` 프로세스입니다. 시스템 부팅 시 가장 먼저 실행되며, 다른 모든 사용자 프로세스의 부모 역할을 합니다.

### 프로세스 주소공간

프로세스 주소공간은 코드(프로그램 코드), 데이터(전역 변수),

 힙(동적 할당 데이터), 스택(함수 호출 및 지역 변수)으로 구성됩니다.

- **초기화되지 않은 변수**: `.bss` 세그먼트에 저장됩니다.
- **스택과 힙의 크기**: 일반적으로 제한적이며, 프로세스 실행 중 동적으로 조정될 수 있습니다. 운영 체제와 프로그램의 메모리 관리 정책에 따라 결정됩니다.
- **접근 속도**: 스택의 접근 속도가 힙보다 일반적으로 빠릅니다. 스택은 LIFO(후입선출) 구조로 되어 있어 최근 데이터에 빠르게 접근할 수 있습니다.
- **공간 분할 이유**: 메모리 관리의 효율성과 유연성을 높이기 위해서입니다. 스택은 함수 호출과 반환에 사용되며, 힙은 동적 메모리 할당에 사용됩니다.
- **스레드 주소공간**: 같은 프로세스 내의 스레드들은 코드, 데이터, 힙 영역을 공유하면서 각자의 스택을 가지고 있습니다.
- **스택과 힙의 자료구조 연관성**: 주소 공간의 스택과 힙은 자료구조의 스택과 힙과 개념적으로 유사합니다. 스택은 함수의 호출과 지역 변수에 사용되는 LIFO 구조, 힙은 동적으로 할당되는 데이터를 저장하는 공간입니다.
- **IPC의 Shared Memory**: 프로세스 간 공유 메모리는 데이터를 공유하기 위한 방법으로, 주소 공간 내의 특정 영역에 매핑됩니다. 이는 프로세스 간 통신을 위해 효율적으로 데이터를 공유할 수 있게 합니다.
- **스택과 힙 영역 크기 결정 시점**: 프로그램 실행 시 운영 체제에 의해 초기 크기가 결정되며, 필요에 따라 동적으로 조정될 수 있습니다. 일반적으로 사용자가 직접 크기를 조정할 수 있는 방법은 제한적입니다.
