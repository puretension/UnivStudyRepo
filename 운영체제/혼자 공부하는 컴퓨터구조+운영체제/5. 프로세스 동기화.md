# 1. 프로세스 동기화
[혼자 공부하는 컴퓨터구조+운영체제(저자 강민철)](https://www.yes24.com/Product/Goods/111378840)과 [유튜브 강의](https://www.youtube.com/watch?v=isj4sZhoxjk&list=PLYH7OjNUOWLUz15j4Q9M6INxK5J3-59GC&index=2)를 보고 정리한 글입니다. 
내용 하단부에는 관련 면접문항으로 정리합니다.

# 1.1. 프로세스 동기화 개요

- 프로세스들의 수행시기를 맞추는 것
- 동시다발적으로 실행되는 프로세스들은 독립적이나, **상호간 협력**이 가능함
- 필요한 이유? 서로 영향을 주고받기 때문에, 실행순서와 자원사용의 **일관성**을 보장해야함 → 동기화
- 실행흐름을 갖는 모든 대상은 동기화 대상임(심지어 `스레드`도!)

### 동기화의 2가지 요구조건

- 실행 순서 제어: 프로세스를 올바른 순서대로 실행
- 상호 배제: 동시에 접근하면 안되는 자원에 하나의 자원만 접근 가능

### 1. 실행 순서 제어를 위한 동기화

- **reader writer problem**
    - Writer: book.txt라는 파일에 값을 저장하는 프로세스
    - Reader: book.txt 파일에 저장된 값을 읽어들이는 프로세스
- 둘은 무작정 아무순서나 실행해서는 안됨 → 실행의 순서가 있기때문
    
    →Reader 프로세스는 “Book.txt안에 값이 존재해야 한다” 라는 조건이 만족해야함
    

### 2. 상호배제를 위한 동기화

- bank account problem
    - 공유가 불가능한(**한 번에 하나의 프로세스만 접근해야하는**) 자원의 동시 사용을 피하기 위한 동기화

<img width="707" alt="스크린샷 2024-03-07 오후 3 37 04" src="https://github.com/puretension/UnivStudyRepo/assets/106448279/a7f369b3-e939-4567-a364-d8e487c36013">

- producer & consumer problem
    - 물건을 계속해서 생산하는 생산자(producer, 프로세스 혹은 스레드)
    - 물건을 계속해서 소비하는 소비자(consumer, 프로세스 혹은 스레드)
    - 둘다 ‘총합’이란 변수를 공유함
    - 생산자를 100,000번, 소비자를 100,000번 실행하면 총합은? → 0과 다른 값
    - 동기화가 되지않았기 때문에 발생한 문제(=**동시 접근 불가한 자원**에 접근해버린 문제)
    
    ```jsx
    // 생산자
    생산자 () {
    	버퍼에 데이터 삽입
    	'총합' 변수 1 증가
    }
    소비자 () {
    	버퍼에 데이터 빼내기
    	'총합' 변수 1 감소
    }
    ```
    

 

위 개념을 더 이해하려면 공유자원과 임계구역에 대해 알아야함

### 공유자원과 임계구역

- 공유 자원(shared resource)
    - 여러 프로세스, 스레드가 공유하는 자원(전역변수, I/O장치, 보조기억장치 등)
- 임계 구역(critical section)
    - 동시에 실행하면 문제가 발생하는 자원에 접근하는 코드영역(앞선 예시의 ‘총합’ 변수, ‘잔액’ 변수)
    - 임계구역에 동시접근시 문제가 발생함
        <img width="657" alt="스크린샷 2024-03-07 오후 3 36 58" src="https://github.com/puretension/UnivStudyRepo/assets/106448279/09d3c2f0-5534-45cf-b825-23b1f3d7c0ee">

        
- 레이스 컨디션(race condition)
    - 여러 프로세스가 임계 구역에 동시 접근하여 자원의 일관성이 깨지는 경우
    - 문맥 교환이 임계 구역에서 발생시 레이스 컨디션 발생함

### 운영체제가 임계구역 문제를 해결하기 위한 3가지 원칙

- 상호 배제(mutual exclusion): 한 프로세스가 임계구역에 진입했다면 다른 프로세스는 들어올 수 없다.
- 진행(progress): 어떠한 프로세스도 임계구역에 진입하지 않았다면 진입하고자 하는 프로세스는 들어갈 수 있어야 한다.
- 유한 대기(bound waiting): 한 프로세스가 임계구역에 진입하고 싶다면 언젠가는 진입할 수 있어야 한다.(무한정 대기 X)

# 2. 동기화 기법

### 동기화의 대표적인 도구

- 뮤텍스 락
- 세마포
- 모니터

## 2.1 뮤텍스 락(Mutex Locks)

### 뮤텍스 락(Mutex Locks)

- 임계구역 문제를 해결하기 위한(상호 배제를 위한) 동기화 도구(자물쇠 역할)
- 임계구역에 진입하기 위해서는 반드시 락을 획득(acquire)해야 하고
- 임계구역을 빠져나올 때 락을 반환(release)해야함

### 뮤텍스 락의 구현

- 하나의 전역변수와 2개의 함수
- 전역 변수 lock: 임계 구역의 자물쇠 역할, 프로세스들이 공유하는 전역 변수
- 함수 acquire: 임계 구역 잠그는 함수
- 함수 release: 임계 구역의 잠금을 해제하는 함수

```jsx
acquire() {
	while(lock == true)    // 만약 임계구역이 잠겨있다면 잠겨있는지를 반복 확인
	;
	lock = true;           // 잠겨있지 않다면? 임계 구역 잠금
}

release() {          
	lock = false;          // 임계 구역 작업이 끝났으니 잠금 해제
}
-------------------------------------------------------------------
// 프로세스의 임계 구역 진입 방식
acquire(); // 자물쇠 lock 여부 확인후 unlock이라면 lock
// 임계구역 작업 수행
release();
```

### 뮤텍스 락 프로세스(임계구역 접근 과정) 정리

- 락 획득(임계구역 진입) 불가하면 무작정 기다리다가, 획득가능해지면 임계 구역 잠근뒤에 작업 수행, 빠져나올땐 임계구역 잠금 해제

### 바쁜 대기(busy wait): 반복적으로 상태가 변경되었는지 확인하며 대기하는 방식

- 뮤텍스 락은 acquire()로 lock여부를 계속 확인함
- `뮤텍스락의 한계`: usable 공유자원 없으면 프로세스는 무한반복하며 공유자원 사용 가능 여부 확인(CPU 주기 낭비)
    
    

## 2.2 세마포(Semaphore)

### 세마포(Semaphore)

- 좀 더 일반화된 방식의 동기화 도구로 `공유자원이 여러 개인 경우`에도 적용 가능(옷장이 여러개인 느낌)
- 이진 세마포(binary semaphore)와 카운팅 세마포(counting semaphore)가 존재함
    - 이진 세마포: 공유자원이 하나이기에 뮤텍스락과 비슷함
    - 카운팅 세마포: 공유자원이 여러개일때(보통 세마포라하면 카운팅 세마포)
- 철도신호기에서 세마포란 단어가 유래

### 세마포의 구현

- 하나의 전역변수와 2개의 함수
- 전역변수 S(뮤텍스는 lock): 임계 구역 진입 가능 프로세스 개수(사용가능 공유자원 개수) 나타냄
- wait 함수: 임계 구역에 들어가도 좋은지, 기다려야 하는지 확인하는 함수
- signal: waiting 프로세스에게 진입가능하다고 신호주는 함수

```jsx
// wait 함수
wait() {
	while(S <= 0) // 임계구역 진입가능 프로세스 개수 0이하라면 사용가능 자원있는지 반복확인
	; 
	S--           // 임계구역 진입가능 프로세스 개수 1이상이면 S감소시키고 임계구역 진입
}

signal() {
	S++           // 임계구역 작업 수행후에 1증가 시킴
}
-------------------------------------------------------------------
wait();
// 임계구역 작업 수행
signal();
```

5번과정을 보면 왜 while문이 존재했는지 알 수 있다(즉각 인식 하고 호출하기때문).

<img width="710" alt="스크린샷 2024-03-07 오후 3 36 48" src="https://github.com/puretension/UnivStudyRepo/assets/106448279/c4c3a759-515e-400e-b5a8-3f569d78612d">

세마포에서도 Busy waiting 문제 발생 → CPU 사이클 낭비!

### 세마포의 Busy Waiting 해결방법

- 세마포는 wait()에서 사용할 수 있는 자원이 없을경우 `대기 상태(waiting)`로 만듦
    
    **(해당 프로세스의 PCB를 대기 큐에 삽입)**
    
- 사용할 수 있는 자원이 생겼을 경우 대기 큐의 프로세스를 준비 상태로 만듦
    
    (**해당 프로세스의 PCB를 대기 큐에서 꺼내서 준비큐에 삽입**)
    

```jsx
// 변경된 wait()
wait() {
 S--;
 if(S < 0) {
	 add proccess p to Queue; // process p의 PCB를 대기큐에 삽입
	 sleep();                 // 대기 상태로 변경 
 }
 
 // 변경된 signal()
 signal() {
	S++;
	if(S <= 0) {
	  remove process p from Queue; // 대기 큐의 프로세스 p 제거 
	  wakeup(p)                     // process p를 대기 상태에서 준비상태로 변경
	}
 }
 
-------------------------------------------------------------------
wait();
// 임계구역 작업 수행
signal();
```

<img width="706" alt="스크린샷 2024-03-07 오후 3 36 39" src="https://github.com/puretension/UnivStudyRepo/assets/106448279/4917f453-fd2e-4b1b-98e9-63440a73d73b">

### 세마포를 활용한 실행순서 동기화

- 세마포의 변수 S를 0으로 두고
- 먼저 실행할 프로세스 뒤에 signal()
- 다음에 실행할 프로세스 앞에 wait()
    
    <img width="537" alt="스크린샷 2024-03-07 오후 3 36 33" src="https://github.com/puretension/UnivStudyRepo/assets/106448279/844fc104-fd14-4e86-81db-ae503ccc6de1">

### 세마포의 한계점

- 임계구역 앞뒤로 wait(), signal()을 정확한 위치에서 호출해야함(바꿔 호출하거나, 중복호출하면..ㅇㅇ)

→ 그래서 등장한게 모니터(Monitor)

## 2.3 모니터(Moniter)

### 

### 모니터

- 공유자원에 접근하는 인터페이스를 묶어서 관리
- 프로세스는 반드시 인터페이스를 통해 공유자원에 접근 가능함
- 인터페이스에 접근할 프로세스는 큐에 삽입되고, 모니터내에는 항상 하나의 프로세스만 들어오도록 하여
  - `상호배재를 위한 동기화`를 실현함
<img width="707" alt="스크린샷 2024-03-07 오후 3 36 26" src="https://github.com/puretension/UnivStudyRepo/assets/106448279/df09f5fa-d79b-4644-803f-b8534eed263b">

- `조건 변수`를 통해 특정조건을 바탕으로 실행 및 일시 중단하여

     →  `실행순서 제어를 위한 동기화` 를 실현함 

### 조건 변수?

- 프로세스나 스레드 실행순서를 제어할때 사용하는 변수
- wait(아래그림의 `x.wait()`)는 호출한 프로세스 상태를 대기상태(ready)로 변경하고 조건변수에 대한 대기큐에 삽입하는 연산임
    - 중요한 점은 `상호배제를 위한 큐(모니터에 진입하기 위한 큐)`와 `조건변수에 대한 큐(wait 호출후에 실행 중단된 프로세스들이 삽입되는 큐)`는 다르다.
    - 모니터에 진입하기 위한 큐는 하나의 프로세시만 모니터에 진입가능하도록 설계된 큐지만
    - 조건변수에 대한 큐는 모니터에 진입한 프로세스가 `실행 조건 만족할때까지 대기하기 위해` 만들어진 큐다.
        
        
        <img width="651" alt="스크린샷 2024-03-07 오후 3 36 08" src="https://github.com/puretension/UnivStudyRepo/assets/106448279/54db84f9-21ce-47d3-9f9d-615550b8b461">
    
    위 그림을 설명하면
    
    특정 프로세스가 모니터에 들어오고, x.wait()가 호출되면 조건변수 x가 만족할때까지 대기한다.
    
    wait 연산으로 실행이 일시 중지된 프로세스는 다른프로세스의 signal 연산으로 실행이 재개된다.
    
    예를들어 x.signal()은 조견변수 x 대기큐에 삽입된 프로세스 실행을 재게하는 함수다(당연)
    

### 모니터에서 프로세스의 실행조건

→ 모니터에는 단 하나의 프로세스만 있을 수 있다!

- wait()호출한 프로세스는 signal()호출한 프로세스가 모니터를 떠난뒤에 실행 재개
- signal()호출한 프로세스의 실행을 일시 중단하고 자신이 실행한 뒤에 다시 signal() 호출한 프로세스의 수행 재개

### 모니터 총정리 하자!

모니터는 **상호배제를 위한 동기화**뿐만아니라 **실행순서 제어를 위한 동기화**도 수행하는데,

특정 프로세스가 아직 실행될 조건이 충족되지않으면 **wait()로 실행을 중단**,

특정 프로세스의 실행조건의 충족되었다면 **signal()로 실행 재개**



### 8. 뮤텍스와 세마포어의 차이점은 무엇인가요?
- 이진 세마포어와 뮤텍스의 차이에 대해 설명해 주세요.
  소유권: 뮤텍스는 소유 가능한 잠금이며, 잠금을 획득한 스레드만이 그 잠금을 해제할 수 있습니다. 반면, 세마포어는 소유 없이 사용되며, 잠금을 획득한 스레드와는 다른 스레드가 잠금을 해제할 수 있습니다.
  이진 세마포어는 뮤텍스처럼 동작할 수 있지만, 소유권이 없어 어떤 스레드든 세마포어를 해제할 수 있지만, 뮤텍스는 잠금을 획득한 스레드만이 잠금을 해제할 수 있어, 이로 인한 데드락을 방지하는 데 더 안전할 수 있습니다.
- Lock을 얻기 위해 대기하는 프로세스들은 Spin Lock 기법을 사용할 수 있습니다. 이 방법의 장단점은 무엇인가요? 단점을 해결할 방법은 없을까요?
  - Spin Lock은 잠금을 획득하기 위해 스레드가 반복적으로 잠금의 상태를 체크하며 대기하는 기법입니다.
  - 장점: 컨텍스트 스위치가 발생하지 않아 잠금을 짧은 시간 동안만 보유할 경우 효율적일 수 있습니다.
  - 단점: 잠금을 획득할 때까지 CPU 시간을 소모하므로, 장시간 잠금을 보유할 경우 CPU 자원을 낭비합니다.
  - 대안: Spin Lock의 단점을 해결하기 위해 하이브리드 접근법을 사용할 수 있습니다. 이 접근법은 초기에는 Spin Lock을 사용하다가 일정 시간이 지나면 슬립 모드로 전환하여 CPU 자원의 낭비를 줄입니다.
- 뮤텍스와 세마포어 모두 커널이 관리하기 때문에, Lock을 얻고 방출하는 과정에서 시스템 콜을 호출해야 합니다. 이 방법의 장단점이 있을까요? 단점을 해결할 수 있는 방법은 없을까요?
  - 장점
    - 일관성과 안정성: 커널 수준에서 제공하는 동기화 메커니즘은 다양한 프로그램과 환경에서 일관되게 동작하며, 잘 정의된 인터페이스를 통해 안정적으로 자원을 관리할 수 있습니다.
    - 보안: 사용자 모드에서 직접 잠금을 관리하는 것보다 커널 모드에서 잠금을 관리하는 것이 시스템의 보안을 강화할 수 있습니다. 잘못된 잠금 해제 시도 등을 커널이 감지하여 방지할 수 있습니다.
    - 데드락 감지: 커널 수준에서 잠금을 관리하면 시스템은 데드락을 감지하고, 필요한 경우 해결하는 메커니즘을 구현할 수 있습니다.
  - 단점
    - 성능 오버헤드: 시스템 콜은 사용자 모드에서 커널 모드로의 컨텍스트 스위치를 필요로 합니다. 이러한 컨텍스트 스위치는 상대적으로 비용이 많이 들며, 잦은 잠금 획득과 방출은 성능 저하를 초래할 수 있습니다.
    - 스케줄링 지연: 시스템 콜 동안, 스레드는 대기 상태에 놓일 수 있으며, 이는 특히 멀티스레드 환경에서 성능 저하의 원인이 될 수 있습니다.
  - 단점 해결 방안
    - 사용자 수준 잠금(User-Level Locks): 사용자 공간에서 잠금 메커니즘을 구현하여 커널로의 전환 없이 잠금을 관리합니다. 이 방법은 컨텍스트 스위치로 인한 오버헤드를 줄일 수 있지만, 데드락 감지 및 해결, 공평한 스케줄링 등 커널 수준의 기능을 모두 구현하기 어렵습니다.
    - 경량화된 동기화 기법: 뮤텍스와 세마포어보다 경량화된 동기화 기법을 사용합니다. 예를 들어, futex(Fast Userspace Mutex)는 사용자 공간에서 대기하다가 필요한 경우에만 커널에 진입합니다. 이러한 방식은 시스템 콜의 수를 줄여 성능을 향상시킬 수 있습니다.
    - 락 프리(Lock-Free) 및 웨이트 프리(Wait-Free) 자료구조: 이들 자료구조는 잠금을 전혀 사용하지 않거나, 스레드 간의 경쟁이 최소화된 알고리즘을 사용하여 구현됩니다. 이러한 접근 방식은 잠금으로 인한 지연 없이 데이터의 동시 접근을 허용하여 성능과 확장성을 향상시킵니다. 그러나 이들 자료구조의 구현과 사용은 복잡하며, 모든 경우에 적합한 것은 아닙니다.
