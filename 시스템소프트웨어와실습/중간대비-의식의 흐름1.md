
LOCCTR을 통해 모든 문장에 주소를 배정하고 모든 LABEL에 저장된 주소값을 SYMTAB[]로 저장하며 어셈블리 지시자도 일부 수행
=> SYMTAB을 채우며 어셈블리지시자(4) 데이터영역의 길이를 결정한다, program length = LOCCTR - starting address

opcode+symtab 조립, byte와 word로 정의되는 데이터 값 생성


SIC VS SIC/XE
메모리 크기 확장 2^15 -> 2^20
B S T F 레지스터추가
부동소수 형식 추가
4개의 명령어형식으로 변화
주소 지정 방식 변화(Direct,Index만 있는 SIC)


address relocation의 방법을 2가지로 나누어 서술하시오
어셈블러와 로더의 합작이다
어셈블러는 라벨들의 주소를 절대주소가 아닌 시작주소로부터의 상대주소로 정한다(그래서 Start가 0이다) H,T,E외에도 Modification record를 만들어 수정이 필요한 부분에 대한 정보를 저장한다(절대주소 사용한 부분)
로더는 수정 레코드를 읽어 실제 시작할때 상대주소를 실제 메모리에 잇는 주소로 변환한다

상수를 바로 피연산자 자리에 쓰면 편함 -> 리터럴(Literal)
LDA =c’EOF’

중복 리터럴 인식 방법 2가지
1)문자열로 리터럴 비교: 구현은 쉽지만 저장공간 효율이 떨어짐
ex) c’EOF’ = x’454F46’ 다름(중복x)로 인식
2)실제 저장된 데이터 비교: 효율성이 높지만 A복잡도가 상승함
ex) c’EOF’ = x’454F46’ 중복으로 인식(실제 저장데이터 값 비교하므로)
 

문자열로 리터럴 인식의 문제점?
1.same name, different value

리터럴 구현
LITTAB[] => {name, value, length, address}

pass 1) LITTAB[] 만들기
리터럴 만나면 LITTAB[]에 존재하는지 확인후 잇다면 중복이니 skip, 없다면추가(주소빼고)
LTORG | END만나면 다음 주소부터 LITTAB읽고 address가 비어있는 리터럴들의 address를 LOCCTR값으로 업데이트함

Pass 2) 
리터럴 만나면 LITTAB에 존재하는지 확인후 존재하면 명령어 operand를 해당 리터럴 address로 -> 없으면 오류
LTORG나 END만나면 오브젝트 프로그램에 리터럴 데이터 추가(리터럴 풀 만들기!)
필요하다면 수정레코드도 생성


pass 1) LITTAB[] 만들기
소스코드를 통과하면서 각 리터럴을 확인하며, 리터럴이 LITTAB에 없다면 그 리터럴은 추가하고(주소는 아직 할당X), 이미 LITTAB에 존재하는 리터럴이면 스킵
LTORG | END 만난이후에는 address가 비어있는 리터럴들 주소를 LOCCTR로 할당

pass 2) 리터럴 참조 처리
리터럴 참조하는 명령어 만나면 LITTAB검색하여 해당 리터럴 주소를 찾고,
해당 리터럴 주소를 피연산자(operand)로 사용하여 LITTAB에 리터럴 없으면 오류가 발생한다
LTORG | END 만나면 오브젝트 프로그램에 리터럴데이터(리터럴풀)를 추가한다
필요하면 수정레코드도 생성

EQU -> #define
+LDT #4096 => MAXLEN EQU 4096하고 +LDT #MAXLEN
목적 프로그램에 코드가 만들어지지않고 바로 상수값이 들어간다

STAB	RESB	1100
SYMBOL	EQU		STAB
VALUE	EQU		STAB+6
FLAGS	EQU		STAB+9
테이블 구조가 불명확하고, value접근시에도 LDA VALUE,X해야함..
STAB	RESB	1100
		ORG		STAB
SYMBOL	RESB	6
VALUE	RESW	1
FLAGS 	RESB	2
		ORG		STAB+1100


당연히 Forward reference problem!


Expression(수식)
: operand부분에 수식작성가능
어셈블러가 계산해서 실제 operand의 주소/값 생성함(어셈블러의 기계독립적특징)

STAB RESW 11*100
STAB RESW (6+3+2)*MAXENTRIES

수식 구성요소
- 연산자: + - * /
- 각 Term
    - 상수(절대 항)
    - user-defined symbol
    - *: 현재 LOCCTR 값
- 각 Term들은 Absolute(상수) | Relative(Address label, LOCCTR(*))

수식 결과도 Absolute | Relative
Absolute
- Absolute Term만 사용
- 반대 부호를 가진 Reletaive Term 한 쌍
Relative
- Absolute의 반대부호쌍 제외하면 하나의 Relative term(양수 +) 여야함
- 곱/나눗셈 적용 불가
- 위 2개에도 속하지않으면 오류

Relative term -> S + r 
Absolute term -> (S + r2) - (S + r1)
아래를 보다시피 flag가 필요한 이유임 => R(Relative term) A(Absolute term) 결정

SYMBOL	TYPE VALUE BUFFER	R	   0036
BUFEND  R	    1036
MAXLEN	 A	    1000



Program blcoks
단일 목적 프로그램에서 재배열된 코드 segments
default - CDATA - CBLKS
어셈블러가 분리된 블럭조각들을 같은종류의 블럭끼리 재배열함(기계독립적 특징)
왜 Program block 사용하는가?(4)
- 같은종류의 블록끼리 재배열하기, 중간중간 데이터 영역 사용가능(가독성 향상)
- 프로그램을 기능별로 분리하여 큰버퍼영역을 맨뒤로함 => 중간에 (큰버퍼영역)있으면 이후주소가 대폭증가하기때문
- 확장 format, BASE Relative Mode사용량이 감소
- 리터럴 풀 배치가 쉬워짐(CDATA)

How?
PASS 1
각블럭마다 LOCCTR 따로 존재함
블럭이 처음 시작되면 0 초기화, 다른블럭바뀌면 저장해두었다가, 이전블럭 재개시 복구
각 label이 속한 (블록기록 +) 블록시작에 대한 상대주소 기록
PASS 1끝날때 LOCCTR 값으로 블록길이표현하며 각 블록의 (목적프로그램에서의) 시작주소를 할당함

PASS 2
각 label이 속한 블록시작에 대한 상대주소 + 각 블록에 할당된 시작주소
(목적프로그램 시작주소 기준) 각 심볼의 실제 상대주소 계산함


How to Handle Control Sections?
Assembler
각 Control Section 독립적으로 처리
각 Control Section LOCCTR 분리
SYMTAB에 각 Symbol 어느 Section인지 저장
다른 Section이면 같은 Symbol 허용
External Reference 정의 안된 Symbol참조하면 오류
목적프로그램에 External Reference위한 정보생성


30	LTORG
33	BUFFER 	RESB 4096
1033	BUFEND	EQU	   *
1000  MAXLEM  EQU	BUFEND-BUFFER


Modification Record는 Linking뿐만아니라, Program Relocation에도 사용된다
