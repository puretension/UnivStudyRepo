## Management Of Real Memory

배경을 알고 들어가야 이해에 도움이 된다.

동시에 1명 이상의 사용자를 지원하는 모든 OS는 병행 프로세스들간에 주기억장치를 분할하는 방식을 제공해야 한다. 많은 다중 프로그래밍 시스템은 각각의 프로세스에 서로 다른 분할이 할당되도록 메모리를 분할 단위로 나눈다. 나뉘어진 분할은 위치와 크기가 고정분할같이 미리정의되거나, 가변분할같이 실행되는 작업의 요구에따라 동적할당되기도한다. 아래에서 분할 메모리 관리의 형태를 살펴보자

### 고정분할과 가변분할

Many multiprogramming and multiprocessing 시스템은

**각각의 프로세스에 서로 다른 분할(partition)이 할당 되도록 메모리를 분할 단위로 나눈다**

- 분할은 2가지 종류가 있다.
    - 미리정의되고, **위치와 크기가 고정**인 고정분할 `(fixed partition)`
    - **실행되는 작업의 요구**에 따라 **동적으로 할당**되는 가변분할 `(variable partition)`

### 고정분할과 가변분할은 각각 어떤 상황에 사용하면 효과적인지와 어떤 방식으로 분할이 이루어지는지 설명하라(이거 답할 수 있으면 고정/가변분할 부분은 점프)

고정분할은 작업 크기가 특정값들로 Cluster될때, 작업크기 자주 안변할때 효과적

가변분할은 작업 크기가 다양해 그 작업크기에 딱맞는 분할을 해야할때 효과적

고정분할은 들어오는 작업을 가장 작은 분할에 할당하는 방식이고

가변분할은 `first-fit allocation, best-fit allocation`방식이다.(추가적으로 가변분할시 OS는 메모리영역의 **linkedList가 유지**관리되고, 분할이 해제되면 **freeList가 반환**된다)

가변분할 기법의 장점은 MultiProgramming 가능, 메모리 사용 효율 높음, Job에 따른 파티션크기만 잘 조절하면 메모리 효율 극대화 
단점은 Fragmentation 메모리 낭비, 전체 사용시 돌아갈 수 있는 큰 프로그램은 못들어감

### 고정분할(fixed Partition)

- 작업 크기가 특정값들로 `cluster`될때, **작업 크기의 분포가** **자주 변하지 않을 때** 효과적
- 들어오는 작업을 **가장 작은 여유 분할에 할당**
- **작업의 파티션 로드(**그 작업의 **실행이 완료될 때까지** 그 파티션에 남아있음)
- 작업 종료후, 파티션 **재사용** 가능⭐️
- **초기 파티션 크기 결정**이 매우 중요(당연한말)

동시에 실행되는 작업의 수를 의미하는 다중프로그래밍의 수준(**level of multi-programming**)은 중앙 메모리에 수용할 수 있는 작업에 의해서만 제한된다

아래처럼 **User Jobs for Memory Allocation(사용자 작업의 메모리 할당** 예)

<img width="161" alt="%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202023-12-01%20%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE%204 58 39" src="https://github.com/puretension/UnivStudyRepo/assets/106448279/5639afd4-494e-4b3f-9663-b3847650aa9a">

### 고정 분할에서의 메모리 할당

<img width="391" alt="Untitled-4" src="https://github.com/puretension/UnivStudyRepo/assets/106448279/9f857aec-3102-4497-9a65-5e2668f30935">

### 가변분할(variable partition)

- **New 작업이 로드** → 그 **작업 크기에 딱 맞는** New 파티션 생성
- 작업이 종료되면, 해당 파티션에 할당된 메모리는 해제되고, 이 메모리는 다른 파티션을 할당하는 데 사용할 수 있게됨(당연함. 처음에, 운영 체제에 할당된 메모리를 제외한 모든 메모리가 할당되지 않은 상태)
- (가변분할 시)운영 체제는 사용 가능한 메모리 영역의 ⭐️`연결 리스트(linked list)`⭐️를 유지 관리해야함
- 분할은 첫 번째 빈 영역**(first-fit allocation**)에 놓이거나,가장 작은 빈 영역(**best-fit allocation**)에 놓임
- 분할이 해제되면 할당된 메모리가 `자유 리스트(free list)`로 반환되고, 인접한 빈 영역과 결합됨

<img width="409" alt="Untitled-5" src="https://github.com/puretension/UnivStudyRepo/assets/106448279/49d73dc4-bb05-486a-8f1e-a30197f1d452">

### Memory Protection, Bound Register

효과적인 메모리보호를위해서 H/W도 지원이 필요하다.

한 분할에서 실행중인 작업은 다른 분할이나 OS가 메모리위치 수정을 못하도록 보호해야한다.

파티션이 사용자 작업에 할당될때 `Bound Register`는 생성되고 이는 **작업분할의 시작주소와 끝주소**를 포함한다.

이 **경계 레지스터의 값들은** `Context Switching` 작업 중에 **자동으로 저장되고 복원된다.**

모든 메모리 참조 시, H/W는 `참조 주소`와 `경계레지스터` 값들을 자동 비교

만약 주소가 현재 작업의 파티션을 벗어나면? **메모리 참조는 수행되지 않고** 프로그램 **인터럽트**가 생성

CPU가 `감독자 모드(supervisor mode)`일 때, 운영 체제는 메모리의 어떤 위치라도 참조**(reference)**할 수 있음

⭐️**Memory Fragmentation**⭐️occurs: **사용 가능한 자유 메모리가 여러 개의 작은 블록**으로 나뉘어 있고, 각 블록이 **너무 작아 사용하기 어려운 상태**를 의미

### Quiz

고정분할과 가변분할의 공통적인 문제로, 분할을 하지않고 메모리를 사용하면 메모리가 충분하지만 여러 작은 사이즈의 프로그램으로 쪼개면 메모리가 충분하지 않아 발생하는 문제는 무엇이며, 해결방법을 서술하라

Memory Fragmentation 문제이며,  여러 작은 사이즈의 프로그램으로 쪼개어 메모리가 불충분할때 발생한다. Demand-paging systems은 fragmentation으로인한 메모리 낭비를 피하는데 효과적이다.

### relocatable partition, relocation register

1. 작업이 종료된 후, 남은 파티션들은 메모리의 한쪽 끝으로 최대한 이동

→ 모든 사용 가능한 자유 메모리를 **하나의 연속된 블록**으로 모으는 데 도움이되고,새로운 파티션을 할당하기에 더 유용한 상태를 만든다

1. **메모리의 한 위치에서 다른 위치로 작업을 복사하는 것은 상당한 시간이 소요**될 수 있다
2. `이동 가능한 파티션(relocatable partition)` 사용은 프로그램의 `재배치(relocation)와 관련된 문제`를 발생시킬 수 있다
3. 실제로, 이동 가능한 파티션을 구현하려면 일부 하드웨어 지원이 필요하다
4. 운영 체제는 특별한 재배치 레지스터(`special relocation register`)를 사용하여 **현재 실행 중인 프로그램의 시작 주소를 설정**한다. 이 레지스터는 프로그램이 메모리 내 어디서 시작되는지를 나타낸다.

### Quiz

운영체제는 variable partition할때 사용가능한 메모리영역의 OO을 유지해야하고, 분할이 해제되면 YY를 반환해야한다. OO와 YY는?

한 분할에서 실행중인 작업은 다른 분할이나 운영체제가 메모리위치 수정을 못하도록 보호해야한다. 효과적인 메모리 보호를 위해 분할의 시작주소와 끝주소를 포함하는 OO을 설정한다. 빈칸에 들어갈 단어는?

**Bound Register**

**Bound Register**는 언제 생성되고, 무엇을 의미하며 어떻게 저장되는가?

**파티션이 사용자 작업에 할당**될때 생성되며, **작업분할의 시작주소와 끝주소를 포함**해야하고 **context switching**중에 자동 저장,복원 된다.

모든 메모리 참조시, 하드웨어는 OO와 YY를 자동 비교한다. OO와 YY는?

동적 기억장소 할당기법의 문제점은?

**Memory Fragmentation**(**사용 가능한 자유 메모리가 여러 개의 작은 블록**으로 나뉘어 있고, **각 블록이 너무 작아** 사용하기 **어려운** 상태)

**Memory Fragmentation 해결방안**은 무엇인지 **키워드**와 함께 **설명하라**

`Relocatable Partition`

→ 작업이 종료된 후 남아있는 분할들은 가능한 한 메모리의 마지막 부분으로 이동시킨다. 이러한 이동은 모든 사용 가능한 자유 메모리를 새로운 분할을 할당하는데 유용한 하**나의 연속된 블록**으로 결합시킨다.(효과적 메모리사용O)

실제 메모리 관리에서 발생할 수 있는 문제는 무엇인가?

현재 실행중인 프로그램의 시작주소를 설정하는 것은 무엇인가?

(special) **relocation register**

### Management Of Virtual Memory

### 가상 메모리 기본 특징

- 컴퓨터에 있는 실제 메모리의 총량보다 **가상 메모리가 더 클 수 있다.**
- 프로그램에 의해 사용되는 가상 메모리는 **외부장치(backing store)에 저장**된다
- 프로그램에서 필요할 때 가상 메모리의 일부가 **실제 메모리로 매핑**된다
- **backing store**와 가상-실제 메모리 매핑**(virtual-to-real mapping)**은 사용자 프로그램에게 **완전히 보이지 않는다.**
- In a typical `demand-paging system` 프로세스의 가상 메모리는 일정한 길이의 **페이지(page)**단위로 분할된다. **demand-paging** 알아놓자
- 컴퓨터의 실제 메모리는 페이지와 같은 길이의 **page frame**으로 분할된다
- 페이지를 페이지 프레임에 매핑하는 것은 PageMapTable(PMT)에 의해 설명되고 시스템의 각 프로세스(페이지)마다 하나의 PMT는 존재한다.

<img width="466" alt="%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202023-12-02%20%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE%207 51 39" src="https://github.com/puretension/UnivStudyRepo/assets/106448279/4701cb75-7434-487f-ad7f-a29d3e7919ca">

위 이미지는 backing store에 저장된 virtual memory를 real memory와 매핑시키는 과정이다.

### PMT? Page Fault? Dynamic Address Translation?

### (가상 메모리를 효율적 관리, 페이지 폴트 처리 방법에 대한 중요한 개념들)

`PMT`는 하드웨어가 **프로그램의 가상 메모리주소**를 해당되는 **실제 메모리주소로 변환**시킬때 사용된다

**요구된 페이지가 메모리에 존재하지 않아 동적주소변환이 이루어지지 못한다면**?

`Page Fault Interrupt` 발생

가상주소를 실제주소로 변환하는 것을 `dynamic address translation`

페이지가 아직 실제 메모리에 로드되지 않았다면, `Page Fault`**란 특별한 타입의 프로그램 인터럽트가 발생**

OS는 모든 **page frame**의 상태를 기술하는 테이블을 유지 관리

페이지 폴트 인터럽트 처리의 첫 단계는 **빈 페이지 프레임을 찾는 것**

**빈 페이지 프레임**이 발견되면 필요한 페이지를 즉시 로드

그렇지 않다면(빈페이지X), 메모리에 있는 페이지 중 하나를 **제거**하여 필요한 페이지를 로드할 공간을 만들어야함

인터럽트 핸들러는 **필요한 페이지를 수신할 페이지 프레임을 선택**하고, 이후의 **페이지 폴트로 인해 다시 선택되지 않도록** 이 프레임을 `Committed` 으로 표시

**페이지를 제거**해야 하는 경우, 해당 페이지를 소유한 **프로세스의 PMT가 페이지의 제거를 반영하도록 업데이트**

페이징 작업이 완료된 후, 인터럽트 핸들러는 저장된 상태 정보를 사용하여 페이지 폴트를 일으킨 명령어로 제어를 반환

최근에 가장 적게 사용된(`LRU`, Least Recently Used) 방법: 메모리 내 각 페이지가 **마지막으로 참조된 시점의 기록을 유지**하고, **가장 오랫동안 사용되지 않은 페이지를 대체**

`프로세스의 working set`: **프로세스에 의해 자주 사용되는 페이지들의 집합**

각 프로세스는 항상 자신의 **working set을 메모리에 보유**

### PMT 구현의 어려움이 있다.

**중앙 메모리에서 배열로 페이지 테이블을 구현(비효율적)**하는 것은 주소 변환에 대한 **추가적인 메모리 접근**이 필요하므로 **비효율적**

**평균 접근 시간을 개선**하기 위해 **고속 버퍼와 함께 기술을 사용**

PMT를 특별한 **고속 연관 메모리(비용)**에서 구현함.

이는 매우 효율적이지만, 실제 메모리가 큰 시스템에서는 **비용이 많이 들 수 있음**

### 그럼 해결책은?

`⭐️Demand-paging systems⭐️` 은 `fragmentation` ******으로 인한 메모리 낭비를 대부분 피할 수 있음******

### why?

프로그램의 특정 실행 동안 사용되지 않는 부분은 **로드할 필요가 없어** 메모리를 절약

하지만 높은 페이징 비율로 인한 서비스 전체의 붕괴를 `thrashing`

**thrashing** 피하기 위해서는 **page fault rate(페이지 부재율)가 훨씬 낮아야**함

메모리 참조는 주소 공간에서 함께 묶여있는 경향이 있음

`locality of reference`으로 인해, **프로그램의 전체 주소를 실제 메모리에 유지하지 않고도** **low** page fault rate 달성 가능

W 페이지 이상이 메모리에 있으면 성능이 만족스러울 것.

‘W’는 프로그램의 페이지 **working set의 크기**

가상 메모리 주소와 실제 메모리 주소의 연결은 메모리 참조가 수행될 때까지 이루어지지 않는다.

보통 프로그램을 동작하면 전체 프로그램에서 실행하는 영역 근처의 메모리만 참조, 처음 1번만 실행되고 안돌리는 부분 why? → `locality of reference`

### **segmented virtual-memory system**

- 주소는 **세그먼트 번호**와 **해당 세그먼트 내의 오프셋**으로 구성
- 세그먼트는 어떤 길이든 OK
- 세그먼트는 프로시저 및 데이터 영역과 같은 **논리적 프로그램 단위에 해당**
- 특정 세그먼트에 대해 `read-only` 또는 `excute-only`과 같은 보호 속성을 연결할 수 있음
- 다른 사용자 작업 간에 **세그먼트 공유가능**
- Segmentation은 종종 **demand paging과 결합**됨
- **two-level mapping 및 주소 변환 절차(address translation procedure)**를 필요함

<img width="543" alt="%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202023-12-02%20%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE%208 06 24" src="https://github.com/puretension/UnivStudyRepo/assets/106448279/e86f7983-979b-49d6-bf42-fe8eb7c96b40">


![IMG_9B35F59D122E-1](https://github.com/puretension/UnivStudyRepo/assets/106448279/6dee23dd-953a-47fa-a1d9-c435968aae13)

### 

![IMG_36DF2D8148D9-1](https://github.com/puretension/UnivStudyRepo/assets/106448279/31e20831-4837-432a-842e-b5dd45e3564c)


### Page Fault Error가 언제 발생하는지와 의미를 서술하라

**요구된 페이지가 메모리에 존재하지 않아 동적주소변환이 이루어지지 못할때 발생한다.**

### Dynamic Address Translation Algorithm 설명하라

H/W로 구현된 DAT 알고리즘은

`page number + offset` 으로 가상 메모리를 **분해**한후

PMT에서 entry를 찾으면서 **메모리내에 page가 있다면**

`page frame address`와 `offset`을 결합하여 **실제 주소를 형성**한다.

만약 `store` 명령어가 있다면 `PMT entry` 표시하여 페이지가 수정됨을 표시한다

메모리내에 page가 없다면? → `Page Fault Interrupt` 발생한다

### Page Fault Algorithm 설명하라

1. 프로세스 상태 저장후 Blocked 표시
2. 빈 페이지 프레임이 있다면

   선택후 `committed` 표시, `PMT 업데이트`, `LPS`로 인터럽트 활성화

   (없다면)제거할 페이지 선택후 `committed` 표시,PMT,LPS

   그 선택된 페이지가 수정된페이지라면 ****

   **backing store**에 페이지를 다시쓰기위해 `I/O request` 발행후 쓰기 작업 완료 대기

3. I/O요청발행후 읽기 작업 완료 대기
4. **PMT와 page frame table**을 업데이트후 `Ready` 표시
5. 페이지 폴트를 일으킨 사용자 프로세스의 상태를 복원